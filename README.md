#Highload C++ | ЛР 1

## Задание

Необходимо написать свою реализацию словаря (в качестве типов можно использовать число для ключа и строку для значения) с операциями вставки, добавления и удаления согласно варианту:
0 - Самобалансирующееся дерево поиска.
1 - Хэш-таблица с цепочками.
2 - Хэш-таблица с открытой адресацией.

Детали реализации (например, организация элементов дерева в памяти, или алгоритм хэширования ключа) остаются на ваше усмотрение.

Для словаря нужно написать бенчмарки, измеряющие скорость вставки, добавления и удаления элементов. Нужно рассмотреть различные сценарии, при которых производительность реализованной структуры будет зависеть от входных данных - вставка данных с большим количеством коллизий для хэш-таблицы, вставка отсортированных данных в B-дерево, и т. д.

Результатом бенчмарков должен быть набор графиков распределения задержки для оптимальных, наихудших, и случайных входных данных. Обратите внимание, что распределения должны быть логически объяснимыми и воспроизводимыми. Может быть полезно сравнить ваше распределение задержек с аналогичным от используемых в стандартной библиотеке структур данных.

Затем, используя инструменты для сэмплирования или трассировки, необходимо определить, что является "бутылочным горлышком" при работе с реализованным словарем. Ответ должен быть подкреплен flamegraph-ами, статистикой сэмплирования либо любым другим способом визуализации задержек.

Дополнительное задание: используя полученную информацию, ускорить свою структуру данных, и подтвердить ускорение еще одной итерацией бенчмарков. В зависимости от качества изначальной имплементации, ускорение может быть как в разы, так и на единицы-десятки процентов.

## Выполнение задания

### Вариант
Мой номер ИСУ: 336739
Мой вариант: 336739 % 3 = 1

### Реализация словаря

Был реализован словарь через хэш-таблицу с цепочками в файле "./src/HashTable.hpp"

Реализация хэш алгоритма была выбрана самая простая - через % от размера словаря.

Пересчет хэшей происходит при заполнении словаря на 85% с расшерением количества бакетов в 2 раза.

### Ускорение

Критическая проблема реализации - количество бакетов является степенью двойки. Таким образом получается любые числа, кратные 2 могут создавать коллизии. 

Ускорение будет заключаться в том, что количество бакетов будет увеличиваться до ближайшего простого числа, ближайшего к степени двойки.


### Бенчмарки


Было подготовленны 2 набора данных:
 - Равноменрно распределенные
 - Создающие коллизию

И проверены на 3 операциях:
 - Вставки
 - Поиска
 - Удаления

Данные были проверены для 1..10000 занчеий c помощью std::chrono и визуализированы через matplotlib.


Первая реализация словаря:
![bencmark 1](./img/1.png)

Улучшенная реализация для словаря:
![bencmark 2](./img/2.png)


### Поиск "Бутылочного горлышка"

Для нахождения "бутылочного горлышка системы был построен flamegraph":



По нему видно, что больше всего времени занимает удадение элементов и при дальнейших оптимизациях надо в первую очередь изменять именно ее.

